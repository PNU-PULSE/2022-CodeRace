# 문제 설명

미래에 실리콘밸리에 있는 자신을 상상하면서 방구석에 누워있는 산지니는 독수리를 사먹기 위해 밖으로 나갔다. 캘리포니아를 꿈꾸며 대로를 따라 걷다가 이상한 그래프를 발견했다.
이 그래프의 특징은 다음과 같다.

- 이 그래프는 1부터 무한하게 번호가 붙어있는 정점들로 이루어져 있다.
- 어떤 정점 번호의 쌍 $(a, b)$이 있을 때 두 수의 쌍이 약수 관계일때만 그 사이에 간선이 양방향으로 $a$에서 $b$로 존재한다. 약수 관계란 두 수의 쌍 $(a, b)$ 중 큰 수를 작은 수로 나눴을 때 나머지가 $0$인 관계다.
- 간선들 중 1번 정점에 연결된 간선 중 짝수 번호와 연결된 가중치는 모두 $2$이며, 그 외 나머지 모든 간선들은 모두 가중치가 $1$이다.

 이때 우리가 알고 싶은 것은 두 정점 $x, y$가 존재할 때, 그 경로가 존재하는지, 그리고 $a$에서 $b$로 가는 경로 중 가중치의 합이 최소인 경로를 구하는 것이다. 만약 가중치의 합이 최소인 경로가 여러 개 존재한다면, 그 중 경로를 지나갈 때 지나가는 정점 번호들의 합이 가장 작은 경로를 출력한다.

### 입력

첫 번째 줄에 쿼리의 갯수 $Q(1 ≤ Q ≤ 3 * 10^5)$가 주어진다.

두 번째 줄부터 $Q + 1$번째 줄까지 정수의 쌍 $(a, b)(1 ≤ a, b ≤ 2 * 10^{7}, a \neq b)$가 주어진다.

### 출력

첫 번째 줄부터 $Q$번째 줄까지 차례대로 각 쿼리에 대한 정답을 출력한다. 

출력은 시작점 $a\quad c_1\quad c_2\quad c_3\quad …. \quad b$의 형태로 각 정점 번호를 한 칸 띄어서 출력한다. 

위의 두 조건에 맞는 경로는 단 하나만 존재함을 증명할 수 있다. 

### 예제

- 입력 1

```python
1
6 8
```

- 출력 1

```python
6 2 8
```

- 예제 설명

6과 8은 약수 관계가 아니므로 경로를 몇 번 더 거쳐야 한다. 6 1 8은 가중치가 4이므로 최소가 되지 않고, 6 2 8이 가중치가 2로 최소이면서 지나가는 정점 번호들의 합의 최소가 된다.

# 알고리즘

- 정수론
- 많은 조건 분기
- 에라스토테네스의 체

# 풀이

경우를 나눠서 생각해봅시다.

일관성을 줘서 $a < b$라고 합시다.

- 만약 $b$가 $a$의 배수라면, 마찬가지로 $a$에서 $b$로 바로 갈 수 있습니다. 그러므로 $a\quad b$가 정답입니다. 아마 $a$가 $1$일때도 있을 것인데, 조건을 잘 생각해보면 마찬가지로 위와 답이 같습니다.

또 다른 경우는 이렇습니다.

- $a$와 $b$가 짝수일 때: 둘 다 짝수이므로 최소 $2$를 공약수로 가집니다. $1$번 정점은 가중치가 $2$나 되므로 가중치의 합의 최소를 만족하지 못합니다. 그러므로 $a\quad 2\quad b$가 정답입니다.
- $a$와 $b$가 홀수일 때: 1번 정점이 있고, 둘 다 홀수 이므로 가중치의 합이 최소를 만족합니다. 그러므로$a\quad 1\quad b$가 정답입니다.
- $a$가 (홀수/짝수)이면 $b$가 (짝수/홀수)일 경우: 이때 $gcd(a, b) \neq 1$인 경우는 $a\quad gcd(a, b)의\quad 최소 약수\quad b$가 정답임은 자명합니다. $a, b$의 범위가 작으므로 $1$을 제외한 최소 약수는 전처리로 에라스토테네스의 체를 응용해서 $O(nlog(logn))$안에 구해줄 수 있습니다. 좀 더 생각해보면 수의 최대 크기가 $2 * 10^7$이므로 $gcd(a, b)$의 최댓값은 $2 * 10^7$에서 $3$을 나눈 값이므로 거기까지만 구해줘도 상관없고, $\sqrt{n}$까지만 탐색해줘도 상관없습니다.
- 그러면 $gcd(a, b) = 1$일때는 어떻게 될까요? $gcd(a, b) = 1$일때는 짝수 하나, 홀수 하나 거쳐서 가중치의 합의 최소가 $3$이 되야할 것처럼 보이지만, $a\quad lcm(a, b)\quad b$라는 경로를 거치면 가중치의 합이 2가 되어 최소를 만족합니다. 그런데 $lcm(a, b) = a * b / gcd(a, b)$ 인데 $gcd(a, b) = 1$이므로 $a\quad a * b\quad b$나 다름없습니다. $a * b$가 $2^{32} - 1$을 넘을 수 있다는 것만 조심해 줍시다.

아까 $a < b$라고 설정했으므로 들어온 순서를 따져서 출력해주면 됩니다. 

시간복잡도: $O(Qlogn + nlog(logn))$

정해 코드

```cpp
#include <bits/stdc++.h>
#define f first
#define s second
using namespace std;
int sv[3500000];
int gcd(int a, int b){
    int c;
    while (b != 0){
        c = a % b;
        a = b;
        b = c;
    }
    return a;
}
void preprocessing(){
    for (int i = 3; i <= 3500000; i += 2){
        if (sv[(i + 1) / 2] == 0) {
            sv[(i + 1) / 2] = i;
            int k = (i << 1);
            for (int j = i; j <= 3500000; j += k){
            	if (sv[(j + 1) / 2] == 0)	sv[(j + 1) / 2] = i;
            }
        }
    }
}
int main(){
    cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(false);
    memset(sv, 0, sizeof(sv));
    preprocessing();
    int q; cin >> q;
    while (q--){
        int a, b; cin >> a >> b;
        if ((b % a == 0) || (a % b == 0)) {
            cout << a << " " << b << "\n";
        }
        else if (a % 2 == 0 && b % 2 == 0){
            cout << a << " " << 2 << " " << b << "\n";
        }
        else if (a % 2 == 1 && b % 2 == 1){
            cout << a << " " << 1 << " " << b << "\n";
        }
        else{
            int p; p = gcd(a, b);
            if (p == 1){
                cout << a << " " << (long long int)a * (long long int)b << " " << b << "\n";
            }
            else{
                cout << a << " " << sv[(p + 1) / 2] << " " << b << "\n";
            }
        }
    }
}
```
